// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// BackupService backup service
//
// swagger:model BackupService
type BackupService struct {

	// application
	Application *NestedCloudTowerApplication `json:"application,omitempty"`

	// backup clusters
	BackupClusters []*NestedCluster `json:"backup_clusters,omitempty"`

	// backup network gateway
	BackupNetworkGateway *string `json:"backup_network_gateway,omitempty"`

	// backup network ip
	BackupNetworkIP *string `json:"backup_network_ip,omitempty"`

	// backup network subnet mask
	BackupNetworkSubnetMask *string `json:"backup_network_subnet_mask,omitempty"`

	// backup network type
	BackupNetworkType *BackupServiceNetworkType `json:"backup_network_type,omitempty"`

	// backup network vlan
	BackupNetworkVlan *string `json:"backup_network_vlan,omitempty"`

	// backup plans
	BackupPlans []*NestedBackupPlan `json:"backup_plans,omitempty"`

	// backup rd iops max
	BackupRdIopsMax *int64 `json:"backup_rd_iops_max,omitempty"`

	// backup store repositories
	BackupStoreRepositories []*NestedBackupStoreRepository `json:"backup_store_repositories,omitempty"`

	// backup wr iops max
	BackupWrIopsMax *int64 `json:"backup_wr_iops_max,omitempty"`

	// description
	Description *string `json:"description,omitempty"`

	// entity async status
	EntityAsyncStatus *EntityAsyncStatus `json:"entityAsyncStatus,omitempty"`

	// id
	// Required: true
	ID *string `json:"id"`

	// kube config
	// Required: true
	KubeConfig *string `json:"kube_config"`

	// management network gateway
	ManagementNetworkGateway *string `json:"management_network_gateway,omitempty"`

	// management network ip
	ManagementNetworkIP *string `json:"management_network_ip,omitempty"`

	// management network subnet mask
	ManagementNetworkSubnetMask *string `json:"management_network_subnet_mask,omitempty"`

	// management network vlan
	ManagementNetworkVlan *string `json:"management_network_vlan,omitempty"`

	// max job retry times
	MaxJobRetryTimes *int32 `json:"max_job_retry_times,omitempty"`

	// max parallel backup jobs
	MaxParallelBackupJobs *int32 `json:"max_parallel_backup_jobs,omitempty"`

	// max parallel restore jobs
	MaxParallelRestoreJobs *int32 `json:"max_parallel_restore_jobs,omitempty"`

	// name
	// Required: true
	Name *string `json:"name"`

	// network status
	NetworkStatus []*NestedBackupServiceNetworkStatus `json:"network_status,omitempty"`

	// restore rd iops max
	RestoreRdIopsMax *int64 `json:"restore_rd_iops_max,omitempty"`

	// restore wr iops max
	RestoreWrIopsMax *int64 `json:"restore_wr_iops_max,omitempty"`

	// retry interval
	RetryInterval *int32 `json:"retry_interval,omitempty"`

	// running vm
	RunningVM *NestedVM `json:"running_vm,omitempty"`

	// status
	Status *BackupServiceStatus `json:"status,omitempty"`

	// storage network gateway
	StorageNetworkGateway *string `json:"storage_network_gateway,omitempty"`

	// storage network ip
	StorageNetworkIP *string `json:"storage_network_ip,omitempty"`

	// storage network subnet mask
	StorageNetworkSubnetMask *string `json:"storage_network_subnet_mask,omitempty"`

	// storage network type
	StorageNetworkType *BackupServiceNetworkType `json:"storage_network_type,omitempty"`

	// storage network vlan
	StorageNetworkVlan *string `json:"storage_network_vlan,omitempty"`
}

// Validate validates this backup service
func (m *BackupService) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateApplication(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackupClusters(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackupNetworkType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackupPlans(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBackupStoreRepositories(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEntityAsyncStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateKubeConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRunningVM(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStorageNetworkType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupService) validateApplication(formats strfmt.Registry) error {
	if swag.IsZero(m.Application) { // not required
		return nil
	}

	if m.Application != nil {
		if err := m.Application.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("application")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("application")
			}
			return err
		}
	}

	return nil
}

func (m *BackupService) validateBackupClusters(formats strfmt.Registry) error {
	if swag.IsZero(m.BackupClusters) { // not required
		return nil
	}

	for i := 0; i < len(m.BackupClusters); i++ {
		if swag.IsZero(m.BackupClusters[i]) { // not required
			continue
		}

		if m.BackupClusters[i] != nil {
			if err := m.BackupClusters[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("backup_clusters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("backup_clusters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupService) validateBackupNetworkType(formats strfmt.Registry) error {
	if swag.IsZero(m.BackupNetworkType) { // not required
		return nil
	}

	if m.BackupNetworkType != nil {
		if err := m.BackupNetworkType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backup_network_type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backup_network_type")
			}
			return err
		}
	}

	return nil
}

func (m *BackupService) validateBackupPlans(formats strfmt.Registry) error {
	if swag.IsZero(m.BackupPlans) { // not required
		return nil
	}

	for i := 0; i < len(m.BackupPlans); i++ {
		if swag.IsZero(m.BackupPlans[i]) { // not required
			continue
		}

		if m.BackupPlans[i] != nil {
			if err := m.BackupPlans[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("backup_plans" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("backup_plans" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupService) validateBackupStoreRepositories(formats strfmt.Registry) error {
	if swag.IsZero(m.BackupStoreRepositories) { // not required
		return nil
	}

	for i := 0; i < len(m.BackupStoreRepositories); i++ {
		if swag.IsZero(m.BackupStoreRepositories[i]) { // not required
			continue
		}

		if m.BackupStoreRepositories[i] != nil {
			if err := m.BackupStoreRepositories[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("backup_store_repositories" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("backup_store_repositories" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupService) validateEntityAsyncStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.EntityAsyncStatus) { // not required
		return nil
	}

	if m.EntityAsyncStatus != nil {
		if err := m.EntityAsyncStatus.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("entityAsyncStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("entityAsyncStatus")
			}
			return err
		}
	}

	return nil
}

func (m *BackupService) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID); err != nil {
		return err
	}

	return nil
}

func (m *BackupService) validateKubeConfig(formats strfmt.Registry) error {

	if err := validate.Required("kube_config", "body", m.KubeConfig); err != nil {
		return err
	}

	return nil
}

func (m *BackupService) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *BackupService) validateNetworkStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkStatus) { // not required
		return nil
	}

	for i := 0; i < len(m.NetworkStatus); i++ {
		if swag.IsZero(m.NetworkStatus[i]) { // not required
			continue
		}

		if m.NetworkStatus[i] != nil {
			if err := m.NetworkStatus[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("network_status" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("network_status" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupService) validateRunningVM(formats strfmt.Registry) error {
	if swag.IsZero(m.RunningVM) { // not required
		return nil
	}

	if m.RunningVM != nil {
		if err := m.RunningVM.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("running_vm")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("running_vm")
			}
			return err
		}
	}

	return nil
}

func (m *BackupService) validateStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.Status) { // not required
		return nil
	}

	if m.Status != nil {
		if err := m.Status.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *BackupService) validateStorageNetworkType(formats strfmt.Registry) error {
	if swag.IsZero(m.StorageNetworkType) { // not required
		return nil
	}

	if m.StorageNetworkType != nil {
		if err := m.StorageNetworkType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storage_network_type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storage_network_type")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this backup service based on the context it is used
func (m *BackupService) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateApplication(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBackupClusters(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBackupNetworkType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBackupPlans(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBackupStoreRepositories(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEntityAsyncStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateRunningVM(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStorageNetworkType(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *BackupService) contextValidateApplication(ctx context.Context, formats strfmt.Registry) error {

	if m.Application != nil {
		if err := m.Application.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("application")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("application")
			}
			return err
		}
	}

	return nil
}

func (m *BackupService) contextValidateBackupClusters(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BackupClusters); i++ {

		if m.BackupClusters[i] != nil {
			if err := m.BackupClusters[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("backup_clusters" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("backup_clusters" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupService) contextValidateBackupNetworkType(ctx context.Context, formats strfmt.Registry) error {

	if m.BackupNetworkType != nil {
		if err := m.BackupNetworkType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("backup_network_type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("backup_network_type")
			}
			return err
		}
	}

	return nil
}

func (m *BackupService) contextValidateBackupPlans(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BackupPlans); i++ {

		if m.BackupPlans[i] != nil {
			if err := m.BackupPlans[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("backup_plans" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("backup_plans" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupService) contextValidateBackupStoreRepositories(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BackupStoreRepositories); i++ {

		if m.BackupStoreRepositories[i] != nil {
			if err := m.BackupStoreRepositories[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("backup_store_repositories" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("backup_store_repositories" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupService) contextValidateEntityAsyncStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.EntityAsyncStatus != nil {
		if err := m.EntityAsyncStatus.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("entityAsyncStatus")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("entityAsyncStatus")
			}
			return err
		}
	}

	return nil
}

func (m *BackupService) contextValidateNetworkStatus(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NetworkStatus); i++ {

		if m.NetworkStatus[i] != nil {
			if err := m.NetworkStatus[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("network_status" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("network_status" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *BackupService) contextValidateRunningVM(ctx context.Context, formats strfmt.Registry) error {

	if m.RunningVM != nil {
		if err := m.RunningVM.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("running_vm")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("running_vm")
			}
			return err
		}
	}

	return nil
}

func (m *BackupService) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status != nil {
		if err := m.Status.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *BackupService) contextValidateStorageNetworkType(ctx context.Context, formats strfmt.Registry) error {

	if m.StorageNetworkType != nil {
		if err := m.StorageNetworkType.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("storage_network_type")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("storage_network_type")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *BackupService) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *BackupService) UnmarshalBinary(b []byte) error {
	var res BackupService
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
