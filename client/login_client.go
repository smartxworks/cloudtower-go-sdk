// Code generated by go-swagger; DO NOT EDIT.

package client

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"

	httptransport "github.com/go-openapi/runtime/client"
	"github.com/go-openapi/strfmt"
	"github.com/smartxworks/cloudtower-go-sdk/v2/client/user"
	"github.com/smartxworks/cloudtower-go-sdk/v2/models"
)

type authConfigData struct {
	AuthnStrategies []authConfig `json:"authnStrategies"`
}

type authConfigHttpRes struct {
	Data authConfigData `json:"data"`
}

type authConfig struct {
	Id   string `json:"id"`
	Type string `json:"type"`
}

func getAuthConfigs(url string) map[string]string {
	var result = make(map[string]string)
	var jsonStr = []byte(`{"operationName":null,"variables":{},"query":"{authnStrategies{id    type}}"}`)
	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonStr))
	if err != nil {
		// for backward compatibility, return empty map instead of error
		return result
	}
	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return result
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return result
	}
	var config authConfigHttpRes
	json.Unmarshal(body, &config)
	for _, data := range config.Data.AuthnStrategies {
		result[data.Type] = data.Id
	}
	return result
}

type ClientConfig struct {
	Host     string
	BasePath string
	Schemes  []string
	formats  *strfmt.Registry
	transport *httptransport.Runtime
}

type UserConfig struct {
	Name     string
	Password string
	Source   models.UserSource
}

func NewWithUserConfig(clientConfig ClientConfig, userConfig UserConfig) (*Cloudtower, error) {
	var transport *httptransport.Runtime
	if clientConfig.transport == nil {
		transport = httptransport.New(clientConfig.Host, clientConfig.BasePath, clientConfig.Schemes)
	} else {
		transport = clientConfig.transport
	}
	var client *Cloudtower
	if clientConfig.formats == nil {
		client = New(transport, strfmt.Default)
	} else {
		client = New(transport, *clientConfig.formats)
	}
	var configId string
	if userConfig.Source == models.UserSourceLDAP {
		// try get auth stategies to replace legacy ldap login source
		straetgyMap := getAuthConfigs(fmt.Sprintf("http://%s/api", clientConfig.Host))
		configId = straetgyMap["LDAP"]
	}
	params := user.NewLoginParams()
	params.RequestBody = &models.LoginInput{
		Username: &userConfig.Name,
		Password: &userConfig.Password,
		Source:   userConfig.Source.Pointer(),
	}
	if configId != "" {
		params.RequestBody.AuthConfigID = &configId
		params.RequestBody.Source = models.UserSourceAUTHN.Pointer()
	}
	resp, err := client.User.Login(params)
	if err != nil {
		return nil, err
	}
	transport.DefaultAuthentication = httptransport.APIKeyAuth("Authorization", "header", *resp.Payload.Data.Token)
	return client, nil
}
